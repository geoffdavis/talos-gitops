apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gitops-lifecycle-management.fullname" . }}-service-discovery-script
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "gitops-lifecycle-management.labels" . | nindent 4 }}
data:
  controller.py: |
    #!/usr/bin/env python3
    """
    GitOps Lifecycle Management Service Discovery Controller
    
    A clean, maintainable Python controller that:
    1. Discovers services with authentik.io/proxy=enabled labels
    2. Creates Authentik proxy providers for discovered services
    3. Updates ProxyConfig resource status
    4. Provides HTTP health endpoints for Kubernetes probes
    """
    
    import os
    import sys
    import json
    import time
    import logging
    import requests
    import subprocess
    from datetime import datetime
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from threading import Thread
    
    # Configure logging
    logging.basicConfig(
        level=getattr(logging, os.getenv('LOG_LEVEL', 'INFO').upper()),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger('service-discovery-controller')
    
    class HealthHandler(BaseHTTPRequestHandler):
        """HTTP handler for health check endpoints"""
        
        def do_GET(self):
            if self.path in ['/healthz', '/readyz']:
                self.send_response(200)
                self.send_header('Content-type', 'text/plain')
                self.end_headers()
                self.wfile.write(b'OK')
            else:
                self.send_response(404)
                self.end_headers()
        
        def log_message(self, format, *args):
            # Suppress default HTTP server logging
            pass
    
    class ServiceDiscoveryController:
        """Main controller class for service discovery and Authentik integration"""
        
        def __init__(self):
            self.authentik_host = os.getenv('AUTHENTIK_HOST')
            self.authentik_token = os.getenv('AUTHENTIK_TOKEN')
            self.authorization_flow = os.getenv('AUTHORIZATION_FLOW')
            self.invalidation_flow = os.getenv('INVALIDATION_FLOW')
            self.cookie_domain = os.getenv('COOKIE_DOMAIN')
            self.reconcile_interval = int(os.getenv('RECONCILE_INTERVAL', '300'))  # 5 minutes default
            
            # Validate required environment variables
            required_vars = ['AUTHENTIK_HOST', 'AUTHENTIK_TOKEN', 'AUTHORIZATION_FLOW', 'INVALIDATION_FLOW']
            missing_vars = [var for var in required_vars if not os.getenv(var)]
            if missing_vars:
                logger.error(f"Missing required environment variables: {missing_vars}")
                sys.exit(1)
        
        def get_proxy_configs(self):
            """Get all ProxyConfig resources from Kubernetes"""
            try:
                result = subprocess.run(
                    ['kubectl', 'get', 'proxyconfigs', '--all-namespaces', '-o', 'json'],
                    capture_output=True, text=True, check=True
                )
                return json.loads(result.stdout).get('items', [])
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to get ProxyConfig resources: {e}")
                return []
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse ProxyConfig JSON: {e}")
                return []
        
        def check_provider_exists(self, provider_name):
            """Check if Authentik proxy provider already exists"""
            try:
                response = requests.get(
                    f"{self.authentik_host}/api/v3/providers/proxy/",
                    headers={'Authorization': f'Bearer {self.authentik_token}'},
                    params={'name': provider_name},
                    timeout=10
                )
                response.raise_for_status()
                return response.json().get('count', 0) > 0
            except requests.RequestException as e:
                logger.error(f"Failed to check provider {provider_name}: {e}")
                return False
        
        def create_proxy_provider(self, config):
            """Create Authentik proxy provider for a ProxyConfig"""
            provider_data = {
                'name': config['spec']['authentikConfig']['providerName'],
                'external_host': f"https://{config['spec']['externalHost']}",
                'internal_host': config['spec']['internalHost'],
                'authorization_flow': self.authorization_flow,
                'invalidation_flow': self.invalidation_flow,
                'cookie_domain': self.cookie_domain,
                'mode': 'forward_single',
                'skip_path_regex': '^/api/.*$',
                'basic_auth_enabled': False,
                'internal_host_ssl_validation': False
            }
            
            try:
                response = requests.post(
                    f"{self.authentik_host}/api/v3/providers/proxy/",
                    headers={
                        'Authorization': f'Bearer {self.authentik_token}',
                        'Content-Type': 'application/json'
                    },
                    json=provider_data,
                    timeout=10
                )
                response.raise_for_status()
                return response.json().get('pk')
            except requests.RequestException as e:
                logger.error(f"Failed to create provider {provider_data['name']}: {e}")
                return None
        
        def update_proxy_config_status(self, config, provider_id=None, error=None):
            """Update ProxyConfig resource status"""
            name = config['metadata']['name']
            namespace = config['metadata']['namespace']
            timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')
            
            if provider_id:
                status_patch = {
                    'status': {
                        'phase': 'Ready',
                        'authentikProviderId': str(provider_id),
                        'lastReconciled': timestamp,
                        'conditions': [{
                            'type': 'Ready',
                            'status': 'True',
                            'lastTransitionTime': timestamp,
                            'reason': 'ProviderCreated',
                            'message': 'Authentik proxy provider created successfully'
                        }]
                    }
                }
            else:
                status_patch = {
                    'status': {
                        'phase': 'Failed',
                        'lastReconciled': timestamp,
                        'conditions': [{
                            'type': 'Ready',
                            'status': 'False',
                            'lastTransitionTime': timestamp,
                            'reason': 'ProviderCreationFailed',
                            'message': f'Failed to create Authentik proxy provider: {error or "Unknown error"}'
                        }]
                    }
                }
            
            try:
                subprocess.run([
                    'kubectl', 'patch', 'proxyconfig', name, '-n', namespace,
                    '--type=merge', '-p', json.dumps(status_patch)
                ], check=True, capture_output=True)
                logger.info(f"Updated ProxyConfig {namespace}/{name} status")
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to update ProxyConfig {namespace}/{name} status: {e}")
        
        def process_proxy_config(self, config):
            """Process a single ProxyConfig resource"""
            name = config['metadata']['name']
            namespace = config['metadata']['namespace']
            provider_name = config['spec']['authentikConfig']['providerName']
            
            logger.info(f"Processing ProxyConfig: {namespace}/{name}")
            
            # Check if provider already exists
            if self.check_provider_exists(provider_name):
                logger.info(f"Provider {provider_name} already exists, skipping creation")
                return
            
            # Create new provider
            logger.info(f"Creating Authentik proxy provider: {provider_name}")
            provider_id = self.create_proxy_provider(config)
            
            if provider_id:
                logger.info(f"Created provider ID: {provider_id}")
                self.update_proxy_config_status(config, provider_id=provider_id)
            else:
                logger.error(f"Failed to create provider for {provider_name}")
                self.update_proxy_config_status(config, error="Provider creation failed")
        
        def run_reconciliation_loop(self):
            """Main reconciliation loop"""
            logger.info("Starting service discovery controller reconciliation loop")
            
            while True:
                try:
                    logger.info("Checking for ProxyConfig resources...")
                    
                    proxy_configs = self.get_proxy_configs()
                    if proxy_configs:
                        logger.info(f"Found {len(proxy_configs)} ProxyConfig resources")
                        for config in proxy_configs:
                            self.process_proxy_config(config)
                    else:
                        logger.info("No ProxyConfig resources found")
                    
                    logger.info(f"Sleeping for {self.reconcile_interval} seconds...")
                    time.sleep(self.reconcile_interval)
                    
                except KeyboardInterrupt:
                    logger.info("Received interrupt signal, shutting down...")
                    break
                except Exception as e:
                    logger.error(f"Error in reconciliation loop: {e}")
                    time.sleep(30)  # Wait 30 seconds before retrying on error
    
    def start_health_server():
        """Start HTTP health check server in background thread"""
        server = HTTPServer(('0.0.0.0', 8081), HealthHandler)
        server_thread = Thread(target=server.serve_forever, daemon=True)
        server_thread.start()
        logger.info("Health check server started on port 8081")
        return server
    
    def main():
        """Main entry point"""
        logger.info("=== GitOps Lifecycle Management Service Discovery Controller ===")
        logger.info("Starting event-driven service discovery controller...")
        
        # Start health check server
        health_server = start_health_server()
        
        # Start main controller
        controller = ServiceDiscoveryController()
        
        try:
            controller.run_reconciliation_loop()
        except KeyboardInterrupt:
            logger.info("Shutting down gracefully...")
        finally:
            health_server.shutdown()
    
    if __name__ == '__main__':
        main()
