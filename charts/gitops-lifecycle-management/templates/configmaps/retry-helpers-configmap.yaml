{{- if .Values.retry.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gitops-lifecycle-management.fullname" . }}-retry-helpers
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "gitops-lifecycle-management.labels" . | nindent 4 }}
  annotations:
    {{- include "gitops-lifecycle-management.annotations" . | nindent 4 }}
data:
  retry-functions.sh: |
    #!/bin/bash
    
    # Enhanced retry function with exponential backoff
    retry_with_backoff() {
      local command="$1"
      local max_attempts="${2:-{{ .Values.retry.defaults.maxAttempts }}}"
      local base_delay="${3:-{{ .Values.retry.defaults.baseDelay }}}"
      local max_delay="${4:-{{ .Values.retry.defaults.maxDelay }}}"
      local backoff_multiplier="${5:-{{ .Values.retry.defaults.backoffMultiplier }}}"
      local jitter="${6:-{{ .Values.retry.defaults.jitter }}}"
      
      local attempt=1
      local delay="$base_delay"
      
      echo "Starting retry operation: $command"
      echo "Max attempts: $max_attempts, Base delay: ${base_delay}s, Max delay: ${max_delay}s"
      
      while [ $attempt -le $max_attempts ]; do
        echo "Attempt $attempt/$max_attempts: Executing command..."
        
        # Execute the command
        if eval "$command"; then
          echo "Command succeeded on attempt $attempt"
          return 0
        fi
        
        # Check if we've reached max attempts
        if [ $attempt -eq $max_attempts ]; then
          echo "Command failed after $max_attempts attempts"
          return 1
        fi
        
        # Calculate next delay with exponential backoff
        if [ "$jitter" = "true" ]; then
          # Add random jitter (Â±25% of delay)
          local jitter_range=$((delay / 4))
          local random_jitter=$((RANDOM % (jitter_range * 2) - jitter_range))
          local actual_delay=$((delay + random_jitter))
          # Ensure delay is positive
          [ $actual_delay -lt 1 ] && actual_delay=1
        else
          local actual_delay="$delay"
        fi
        
        # Cap delay at max_delay
        [ $actual_delay -gt $max_delay ] && actual_delay="$max_delay"
        
        echo "Command failed, waiting ${actual_delay}s before retry..."
        sleep "$actual_delay"
        
        # Calculate next delay
        delay=$((delay * backoff_multiplier))
        attempt=$((attempt + 1))
      done
      
      return 1
    }
    
    # Database connectivity check with retry
    wait_for_database() {
      local host="$1"
      local port="$2"
      local database="$3"
      local user="$4"
      local password="$5"
      local max_attempts="${6:-{{ .Values.retry.services.database.maxAttempts }}}"
      local timeout="${7:-{{ .Values.retry.services.database.timeout }}}"
      
      echo "Waiting for database: $host:$port/$database"
      
      # Set environment variables for psql
      export PGHOST="$host"
      export PGPORT="$port"
      export PGDATABASE="$database"
      export PGUSER="$user"
      export PGPASSWORD="$password"
      export PGSSLMODE="require"
      export PGCONNECT_TIMEOUT="10"
      
      local start_time=$(date +%s)
      
      retry_with_backoff \
        "psql -c 'SELECT 1;' >/dev/null 2>&1" \
        "$max_attempts" \
        {{ .Values.retry.services.database.baseDelay }} \
        {{ .Values.retry.services.database.maxDelay }} \
        {{ .Values.retry.defaults.backoffMultiplier }} \
        {{ .Values.retry.defaults.jitter }}
      
      local result=$?
      local end_time=$(date +%s)
      local duration=$((end_time - start_time))
      
      if [ $result -eq 0 ]; then
        echo "Database connectivity established in ${duration}s"
      else
        echo "Database connectivity failed after ${duration}s"
      fi
      
      return $result
    }
    
    # Service connectivity check with retry
    wait_for_service() {
      local host="$1"
      local port="$2"
      local service_name="${3:-service}"
      local max_attempts="${4:-{{ .Values.retry.defaults.maxAttempts }}}"
      local timeout="${5:-{{ .Values.retry.defaults.timeout }}}"
      
      echo "Waiting for $service_name: $host:$port"
      
      local start_time=$(date +%s)
      
      retry_with_backoff \
        "nc -z -w5 '$host' '$port'" \
        "$max_attempts" \
        {{ .Values.retry.defaults.baseDelay }} \
        {{ .Values.retry.defaults.maxDelay }} \
        {{ .Values.retry.defaults.backoffMultiplier }} \
        {{ .Values.retry.defaults.jitter }}
      
      local result=$?
      local end_time=$(date +%s)
      local duration=$((end_time - start_time))
      
      if [ $result -eq 0 ]; then
        echo "$service_name connectivity established in ${duration}s"
      else
        echo "$service_name connectivity failed after ${duration}s"
      fi
      
      return $result
    }
    
    # HTTP endpoint check with retry
    wait_for_http_endpoint() {
      local url="$1"
      local expected_status="${2:-{{ .Values.retry.services.http.healthCheck.expectedStatus }}}"
      local max_attempts="${3:-{{ .Values.retry.services.http.maxAttempts }}}"
      local timeout="${4:-{{ .Values.retry.services.http.timeout }}}"
      
      echo "Waiting for HTTP endpoint: $url (expecting status $expected_status)"
      
      local start_time=$(date +%s)
      
      retry_with_backoff \
        "curl -s -o /dev/null -w '%{http_code}' '$url' | grep -q '$expected_status'" \
        "$max_attempts" \
        {{ .Values.retry.services.http.baseDelay }} \
        {{ .Values.retry.services.http.maxDelay }} \
        {{ .Values.retry.defaults.backoffMultiplier }} \
        {{ .Values.retry.defaults.jitter }}
      
      local result=$?
      local end_time=$(date +%s)
      local duration=$((end_time - start_time))
      
      if [ $result -eq 0 ]; then
        echo "HTTP endpoint ready in ${duration}s"
      else
        echo "HTTP endpoint failed after ${duration}s"
      fi
      
      return $result
    }
    
    # Graceful shutdown handler
    setup_graceful_shutdown() {
      local cleanup_function="${1:-cleanup}"
      
      # Trap signals for graceful shutdown
      trap "echo 'Received shutdown signal, cleaning up...'; $cleanup_function; exit 0" TERM INT
      
      # Default cleanup function
      cleanup() {
        echo "Performing cleanup..."
        # Kill any background processes
        jobs -p | xargs -r kill
        # Remove temporary files
        rm -rf /tmp/retry_* 2>/dev/null || true
        echo "Cleanup completed"
      }
    }
{{- end }}